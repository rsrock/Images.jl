<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Tim Holy">
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Core Concepts - Images.jl</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../assets/Documenter.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">Images.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../aims/">Aims</a>
</li>

                        
                            
<li class="active">
    <a href="./">Core Concepts</a>
</li>

                        
                            
<li >
    <a href="../overlays/">Overlays</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../function_reference/">Function Reference</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../aims/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../overlays/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/rsrock/Images.jl.git">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#julia-images-guide">Julia Images Guide</a></li>
        
            <li><a href="#the-basic-types">The basic types</a></li>
        
            <li><a href="#addressing-image-data">Addressing image data</a></li>
        
            <li><a href="#image-properties-and-accessor-functions">Image properties and accessor functions</a></li>
        
            <li><a href="#writing-generic-algorithms">Writing generic algorithms</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><a id='Julia-Images-Guide-1'></a></p>
<h1 id="julia-images-guide">Julia Images Guide</h1>
<p><a id='The-basic-types-1'></a></p>
<h2 id="the-basic-types">The basic types</h2>
<p><a id='Plain-arrays-1'></a></p>
<h3 id="plain-arrays">Plain arrays</h3>
<p>Images can be plain arrays, which are interpreted to be in "Matlab format": the first two dimensions are height (<code>h</code>) and width (<code>w</code>), a storage order here called "vertical-major". This ordering is inspired by the column/row index order of matrices and the desire to have a displayed image look like what one sees when a matrix is written out in text.</p>
<p>If you're working with RGB color, your best approach is to encode color as a <code>Color</code>, as defined in the <code>Color</code> package.  That package provides many utility functions for analyzing and manipulating colors.  Alternatively, you can use a third dimension of size 3, or encode your images as either <code>RGB24</code> or <code>ARGB32</code>, which use an internal <code>Uint32</code> representation of color.</p>
<p>It's worth noting that these Matlab conventions are sometimes inconvenient.  For example, the <code>x</code> coordinate (horizontal) is second and the <code>y</code> coordinate (vertical) is first; in other words, one uses <code>img[y,x]</code> to address a pixel that is displayed at a particular <code>x,y</code> position. This often catches newcomers (and sometimes even old-timers) by surprise.  Moreover, most image file formats, cameras, and graphics libraries such as Cairo use "horizontal-major" storage of images, and have the color dimension first (fastest). The native Image type–-which allows arbitrary ordering of the data array–-permits you to use this raw representation directly, but when using plain arrays you need to permute the dimensions of the raw data array.</p>
<p>The convention that a <code>m x n x 3</code> array implies RGB is also problematic for anyone doing 3d imaging, and can result in hard-to-find bugs when the third dimension happens to be of size 3. For 3d imaging, the use of an Image type–-perhaps converting Arrays via <code>grayim</code>–-is highly recommended.</p>
<p>The conventions for plain arrays are "baked in" via a few simple utility functions in the file <code>core.jl</code>; if you really need to use plain arrays but want to work with different conventions, you can (locally) change these defaults with just a few lines. Algorithms which have been written generically should continue to work.</p>
<p>However, a more flexible approach is to use one of the self-documenting image types.</p>
<p><a id='Image-types-1'></a></p>
<h3 id="image-types">Image types</h3>
<p>All image types should descend from <code>AbstractImage</code>, an abstract base type used to indicate that an array is to be interpreted as an image. If you're writing a custom image type, it is more likely that you'll want to derive from either <code>AbstractImageDirect</code> or <code>AbstractImageIndexed</code>. The former is for direct images (where intensity at a pixel is represented directly), the latter for indexed images (where intensity is looked up in a colormap table).</p>
<p>In practice, it is assumed that <code>AbstractImages</code> have at least two fields, called <code>data</code> and <code>properties</code>. (In code, you should not use these directly, instead using the functions <code>data</code> and <code>properties</code> to extract these.)  These are the only two fields in the first concrete image type, called <code>Image</code>:</p>
<pre><code class="julia">type Image{T,N,A&lt;:AbstractArray} &lt;: AbstractImageDirect{T,N}
    data::A
    properties::Dict{ASCIIString,Any}
end
</code></pre>

<p><code>data</code> stores the actual image data, and is an <code>AbstractArray</code>. This fact alone is the basis for a great deal of customizability: <code>data</code> might be a plain <code>Array</code> stored in memory, a <code>SubArray</code>, a memory-mapped array (which is still just an <code>Array</code>), a custom type that stores additional information about "missing data" (like bad pixels or dropped frames), or a custom type that seamlessly presents views of a large number of separate files.  One concrete example in the Images codebase is the color <code>Overlay</code> <a href="../overlays.html">type</a>.  If you have a suitably-defined <code>AbstractArray</code> type, you can probably use <code>Image</code> without needing to create alternative <code>AbstractImageDirect</code> types.</p>
<p><code>properties</code> is a dictionary, with <code>String</code> keys, that allows you to annotate images. More detail about this point can be found below.</p>
<p>The only other concrete image type is for indexed images:</p>
<pre><code class="julia">type ImageCmap{T,N,A&lt;:AbstractArray,C&lt;:AbstractArray} &lt;: AbstractImageIndexed{T,N}
    data::A
    cmap::C
    properties::Dict{ASCIIString,Any}
end
</code></pre>

<p>The <code>data</code> array here just encodes the index used to look up the color in the <code>cmap</code> field.</p>
<p><a id='Addressing-image-data-1'></a></p>
<h2 id="addressing-image-data">Addressing image data</h2>
<p>For any valid image type, <code>data(img)</code> returns the array that corresponds to the image.  This works when <code>img</code> is a plain <code>Array</code> (in which case no operation is performed) as well as for an <code>Image</code> (in which case it returns <code>img.data</code>). For some image formats, Images.jl may interpret raw data with the <code>FixedPointNumbers</code> package. The function <code>raw(img)</code> can be used to recover the buffer in its raw format (e.g. <code>UInt8</code>). This is our first example of how to write generic algorithms.</p>
<p>If <code>img</code> is an <code>Image</code>, then <code>img[i,j]</code> looks up the value <code>img.data[i,j]</code>. Assignment, <code>sub</code>, and <code>slice</code> work similarly. In other words, for indexing an <code>Image</code> works just as if you were using plain arrays.</p>
<p>If you load your image data using Image's <code>imread</code>, note that the storage order is not changed from the on-disk representation. Therefore, a 2D RGB image will most likely be stored in color-horizontal-vertical order, meaning that a pixel at <code>(x,y)</code> is accessed as <code>img[x,y]</code>. Note that this is quite different from Matlab's default representation.</p>
<p>If you are indexing over an extended region and want to get back an <code>Image</code>, rather than a value or an <code>Array</code>, then you will want to use <code>getindexim</code>, <code>subim</code>, and <code>sliceim</code>. For the first two, the resulting image will share everything but the <code>data</code> field with the original image; if you make modifications in one, the other will also be affected. For <code>sliceim</code>, because it can change the dimensionality some adjustments to <code>properties</code> are needed; in this case a copy is made.</p>
<p>One of the properties (see below) that you can grant to images is <code>spatialorder</code>, which provides a name for each spatial dimension in the image. Using this feature, you can cut out regions or slices from images in the following ways:</p>
<pre><code class="julia">A = img[&quot;x&quot;, 200:400, &quot;y&quot;, 500:700]
imgs = sliceim(img, &quot;z&quot;, 14)      # cuts out the 14th frame in a stack
</code></pre>

<p>These routines "do the right thing" no matter what storage order is being used.</p>
<p><a id='Image-properties-and-accessor-functions-1'></a></p>
<h2 id="image-properties-and-accessor-functions">Image properties and accessor functions</h2>
<p>The <code>properties</code> dictionary can contain any information you want to store along with your images. Typically, each property is also affiliated with an accessor function of the same name.</p>
<p>Let's illustrate this with one of the default properties, <code>"colorspace"</code>. The value of this property is a string, such as <code>"RGB"</code> or <code>"Gray"</code> or <code>"HSV"</code>. You can extract the value of this field using a function:</p>
<pre><code class="julia">cs = colorspace(img)
</code></pre>

<p>The reason to have a function, rather than just looking it up in the <code>properties</code> dictionary, is that we can provide defaults. For example, images represented as plain <code>Array</code>s don't have a <code>properties</code> dictionary; if we are to write generic code, we don't want to have to wonder whether this information is available. So for plain arrays, there are a number of defaults specified for the output of the <code>colorspace</code> function, depending on the element type and size of the array. Likewise, images stored as <code>Color</code> arrays have no need of a <code>"colorspace"</code> property, because the colorspace is encoded in the type parameters.</p>
<p>Here is a list of the properties supported in <code>core.jl</code>:</p>
<ul>
<li><code>colorspace</code>: "RGB", "RGBA", "Gray", "Binary", "24bit", "Lab", "HSV", etc.  If   your image is represented as a Color array, you cannot override that   choice by specifying a <code>colorspace</code> property.  (Use <code>reinterpret</code> if you want   to change the interpretation without changing the raw values.)</li>
<li><code>colordim</code>: the array dimension used to store color information, or 0 if there   is no dimension corresponding to color</li>
<li><code>timedim</code>: the array dimension used for time (i.e., sequence), or 0 for single   images</li>
<li><code>scalei</code>: a property that controls default contrast scaling upon display.   This should be a   <a href="../function_reference.html#mapinfo"><code>MapInfo</code></a>   value, to be used for setting the contrast upon display. In the absence of   this property, the range 0 to 1 will be used.</li>
<li><code>pixelspacing</code>: the spacing between adjacent pixels along spatial dimensions</li>
<li><code>spacedirections</code>: more detailed information about the orientation of array   axes relative to an external coordinate system (see the   <a href="../function_reference.html">function reference</a>).</li>
<li><code>spatialorder</code>: a string naming each spatial dimension of the array, in the   storage order of the data array.  Names can be arbitrary, but the choices "x"   and "y" have special meaning (horizontal and vertical, respectively,   irrespective of storage order).  If supplied, you must have one entry per   spatial dimension.</li>
</ul>
<p>If you specify their values in the <code>properties</code> dictionary, your values will be used; if not, hopefully-reasonable defaults will be chosen.</p>
<p>Naturally, you can add whatever additional properties you want: you could add the date/time at which the image was captured, the patient ID, etc. The main point of having a properties dictionary, rather than a type with fixed fields, is the flexibility of adding whatever metadata you find to be useful.</p>
<p><a id='Writing-generic-algorithms-1'></a></p>
<h2 id="writing-generic-algorithms">Writing generic algorithms</h2>
<p>Let's say you have an algorithm implemented for <code>Array</code>s, and you want to extend it to work on <code>Image</code> types. Let's consider the example of a hypothetical <code>imfilter</code>, written to perform kernel-based filtering in arbitrary dimensions. Let's say your <code>imfilter</code> looks like this:</p>
<pre><code class="julia">function imfilter{T,N}(A::Array{T,N}, kernel::Array{T,N}, options...)
</code></pre>

<p>The first step might be to simply provide a version for <code>AbstractImage</code> types:</p>
<pre><code class="julia">function imfilter{T,N}(img::AbstractImage{T,N}, kernel::Array{T,N}, options...)
    out = imfilter(data(img), kernel, options...)
    shareproperties(img, out)
end
</code></pre>

<p>Now let's say you additionally want to allow the user to filter color images–-where one dimension of the array is used to encode color–-with a filter of dimension <code>N-1</code> applied to each color channel separately. We can implement this version simultaneously for both <code>Image</code> types and other array types as follows:</p>
<pre><code class="julia">function imfilter{T,N,N1}(img::AbstractArray{T,N}, kernel::Array{T,N1}, options...)
    cd = colordim(img)
    if N1 != N - (cd != 0)
        error(&quot;kernel has the wrong dimensionality&quot;)
    end
    out = similar(img)
    for i = size(img, cd)
        imsl = img[&quot;color&quot;, i]
        outsl = slice(out, &quot;color&quot;, i)
        copy!(outsl, imfilter(imsl, kernel, options...))
    end
    out
end
</code></pre>

<p>There are other ways to achieve a similar effect; if you examine the actual implementation of <code>imfilter</code>, you'll see that the kernel is reshaped to be commensurate with the data array.</p>
<p>These solutions work no matter which dimension is used to store color, a feat that would be essentially impossible to achieve robustly in a generic algorithm if we didn't exploit metadata. Note also that if the user supplies an <code>Array</code>, s/he will get an <code>Array</code> back, and if using an <code>Image</code> will get an <code>Image</code> back with properties inherited from <code>img</code>.</p>
<p>Naturally, you can find other examples of generic implementations throughout the source code of <code>Images</code>.</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../assets/mathjaxhelper.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
